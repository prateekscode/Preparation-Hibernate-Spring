------------------------------------------Dependency Injections	Constructor injection	public BinaySearchImpl(SortAlgorithm sortAlgorithm) {
		super();
		this.sortAlgorithm = sortAlgorithm;
	}

	setter injection
	if no setter or constructor it will use setter injection
	
	for optional depndency use setter
	and for mandatory dependency use constructor
	
public void setSortAlgorithm(SortAlgorithm sortAlgorithm) {
		this.sortAlgorithm = sortAlgorithm;
	}	------------------------------------------------------Scope -Prototype/SingletonBy defaults its--> Singleton@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) WE CAN MAKE IT ALSOSINGLE INSTANCE WE GET EVERYTIME FOR SAME BEAN WHEN WE USE context.getBean();-->Prototype@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)WE GET DIFFERNT INSTANCE EVERYTIME FOR SAME BEAN WE USE context.getBean();	---->If we are going to make class prototype we get different instance for classbut for dependency we get same. ---->But if we are going to make dependency class prototype we get same instance notdifferent.---->If we want different instance for dependency class we have to use proxy@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, 							proxyMode = ScopedProxyMode.TARGET_CLASS)------------------------------------------------->Singleton GOF Vs Singleton Scope SpringSingleton GOF--->One instance of bean per JVMSingleton Scope Spring--->One instance of bean per ApplicationContext-------------------------------------------->Component class in diff. packso, we have to specify ---@ComponentScan("com.spring.basics.componentscan") in application class---------------------------------------------->Bean LifecycleEntire Bean Lifecycle is managed by Spring IOC container  this container will create instance of bean an also make sure that bean is destroyed once itsno longer needed.@PostConstruct--->As soon as the bean is created and initialized with thedependencies the method in which this annotation is applied will be called.  @PreDestroy--->Just before the bean is removed out of the container themethod in which this annotation is applied will be called.----------------------------------------->CDI(Context and Dependency Injection)Its similar to previous annotations for this we have to use this dependency--<dependency>			<groupId>javax.inject</groupId>			<artifactId>javax.inject</artifactId>			<version>1</version></dependency>-->Java EE aDependency Injection Standard (JSR-30)-->Spring supports most annotations@Inject(@Autowired)@Named(@Components and @Qualifier@Singleton(Defines a scope of Singleton) --------------------------------->@Component|@Service|@Repository|@ControllerWhen we talk about any applications it has typically three parts--Web layer(UI)Business layer(Business logic)Data layer(Getting data might be from database or external interface)@Component--->It is very generic any of these layer if we are not sure ifsomething belongs to one of the layer we can use @Component.However, other three annotations are very very specific@Controller-->It is used to define a controller in the web layer (In MVC).@Service--->It is used in business service layer.@Repository--->It is used in data layer. ---------------------------------------------------->JunitLarge appli.can have 1000s lines of code files and millions of lines of code.Testing-->Check app behavior against expected bahavior 1--Deploy the complete app and testCalled System testing or Integration testing.2--Test specific units of application code independentlyEx: A specific method or group of methodsCalled Unit testing.Advantage of Unit testing-->Find bugs early(run under continuous integration)							Easy to fix bugs							Reduces costs in the long runMost popular java Frameworks:JUnit and Mockito.--->Junit framework does not gaurantee the execution in the same order we define test methods it may vary.------------------------------------------------->MockitoWe write unit test for classes with multiple dependencies using Mockito.-------------------------------------------------->SpringBootBefore Spring Boot setting up spring projects was not easy1. Dependency management(pom.xml)2. Define Web App Configuration(web.xml)3. mange spring Beans(context.xml)4. Implement Non-functional RequirementsAnd repeat this for every new projectSpring boot help us build production-ready app quickly-->Build quickly--Spring initializr--Spring Boot Starter Projects--Spring Boot Auto Configuration--Spring Boot Devtools-->Be Production-ready--Logging--Diff. Confi. for Diff. Enviornmentss----Profiles, ConfigurationProperties--Monitoring(Spring Boot Actuator)--------------------------------------------->Spring boot StarterI need a lot of frameworks to build application features:■ Build a REST API: I need Spring, Spring MVC, Tomcat, JSON conversion... ■ Write Unit Tests: I need Spring Test, JUnit, Mockito, ...How can I group them and make it easy to build applications?■ Starters: Convenient dependency descriptors for diff. featuresSpring Boot provides variety of starter projects:▪ Web Application & REST API - Spring Boot Starter Web (spring-webmvc, spring-web, spring-boot-starter-tomcat, spring-boot-starter-json)■ Unit Tests - Spring Boot Starter Test■ Talk to database using JPA - Spring Boot Starter Data JPA■ Talk to database using JDBC - Spring Boot Starter JDBC■Secure your web application or REST API - Spring Boot Starter Security------------------------------------------------>Spring Boot Auto Configuration• I need lot of configuration to build Spring app:·Component Scan, DispatcherServlet, Data Sources, JSON Conversion, ...• How can I simplify this?■ Auto Configuration: Automated configuration for your app• Decided based on:• Which frameworks are in the Class Path?• What is the existing configuration (Annotations etc)?Example: Spring Boot Starter Web·Dispatcher Servlet (DispatcherServletAutoConfiguration) ■ EmbeddedServlet ContainerTomcat is thedefault(EmbeddedWebServerFactoryCustomizerAutoConfiguration)■ Default Error Pages (ErrorMvcAutoConfiguration)■ Bean<->JSON(JacksonHttpMessageConvertersConfiguration)------------------------------------------------->SpringBoot DevtoolsIncrease developer productivityWhy do you need to restart the server manually for every code change?-->If there is changes in any code or properties file we don't have to restart the application.Remember: For pom.xml dependency changes, you will need to restart server manually.----------------------------------------->SpringBoot Production Ready with ProfilesApplications have different environments: Dev, QA, Stage, Prod, ...Different environments need different configuration:■ Different Databases■ Different Web ServicesHow can you provide different configuration for different environments?■ Profiles: Environment specific configuration---->Logging levels trace	|	it will print all below levelsdebug	|	info	|warning	|error	-off	 		it will stop all logs--------------------------------------------------->SpringBoot Actuator• Monitor and manage your application in your production• Provides a number of endpoints:■ beans - Complete list of Spring beans in your app■ health - Application health information■ metrics - Application metrics■ mappings - Details around Request Mappings--------------------------------->Understanding Spring Boot vs Spring MVC vs SpringSpring Boot vs Spring MVC vs Spring: What's in it?Spring Framework: Dependency Injection@Component, @Autowired, Component Scan etc..• Just Dependency Injection is NOT sufficient (You need other frameworks to build apps)• Spring Modules and Spring Projects: Extend Spring Eco System• Provide good integration with other frameworks (Hibernate/JPA, JUnit & Mockito for Unit Testing)Spring MVC (Spring Module): Simplify building web apps and REST API-->Before Spring MVC building web applications with Struts was very complex@Controller, @RestController, @RequestMapping("/courses")Spring Boot (Spring Project): Build PRODUCTION-READY apps QUICKLY• Starter Projects - Make it easy to build variety of applications• Auto configuration - Eliminate configuration to setup Spring, Spring MVC and other frameworks!• Enable non functional requirements (NFRs):• Actuator: Enables Advanced Monitoring of applications• Embedded Server: No need for separate application servers!。 Logging and Error Handling• Profiles and Configuration Properties
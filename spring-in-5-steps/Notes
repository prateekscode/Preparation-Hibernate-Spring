------------------------------------------Dependency Injections	Constructor injection	public BinaySearchImpl(SortAlgorithm sortAlgorithm) {
		super();
		this.sortAlgorithm = sortAlgorithm;
	}

	setter injection
	if no setter or constructor it will use setter injection
	
	for optional depndency use setter
	and for mandatory dependency use constructor
	
public void setSortAlgorithm(SortAlgorithm sortAlgorithm) {
		this.sortAlgorithm = sortAlgorithm;
	}	------------------------------------------------------Scope -Prototype/SingletonBy defaults its--> Singleton@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) WE CAN MAKE IT ALSOSINGLE INSTANCE WE GET EVERYTIME FOR SAME BEAN WHEN WE USE context.getBean();-->Prototype@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)WE GET DIFFERNT INSTANCE EVERYTIME FOR SAME BEAN WE USE context.getBean();	---->If we are going to make class prototype we get different instance for classbut for dependency we get same. ---->But if we are going to make dependency class prototype we get same instance notdifferent.---->If we want different instance for dependency class we have to use proxy@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, 							proxyMode = ScopedProxyMode.TARGET_CLASS)------------------------------------------------->Singleton GOF Vs Singleton Scope SpringSingleton GOF--->One instance of bean per JVMSingleton Scope Spring--->One instance of bean per ApplicationContext-------------------------------------------->Component class in diff. packso, we have to specify ---@ComponentScan("com.spring.basics.componentscan") in application class---------------------------------------------->Bean LifecycleEntire Bean Lifecycle is managed by Spring IOC container  this container will create instance of bean an also make sure that bean is destroyed once itsno longer needed.@PostConstruct--->As soon as the bean is created and initialized with thedependencies the method in which this annotation is applied will be called.  @PreDestroy--->Just before the bean is removed out of the container themethod in which this annotation is applied will be called.----------------------------------------->CDI(Context and Dependency Injection)Its similar to previous annotations for this we have to use this dependency--<dependency>			<groupId>javax.inject</groupId>			<artifactId>javax.inject</artifactId>			<version>1</version></dependency>-->Java EE aDependency Injection Standard (JSR-30)-->Spring supports most annotations@Inject(@Autowired)@Named(@Components and @Qualifier@Singleton(Defines a scope of Singleton) --------------------------------->@Component|@Service|@Repository|@ControllerWhen we talk about any applications it has typically three parts--Web layer(UI)Business layer(Business logic)Data layer(Getting data might be from database or external interface)@Component--->It is very generic any of these layer if we are not sure ifsomething belongs to one of the layer we can use @Component.However, other three annotations are very very specific@Controller-->It is used to define a controller in the web layer (In MVC).@Service--->It is used in business service layer.@Repository--->It is used in data layer. 